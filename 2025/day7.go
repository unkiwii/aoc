package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"

	"github.com/unkiwii/aoc/lib/stack"
)

// --- Day 7: Laboratories ---
//
// You thank the cephalopods for the help and exit the trash compactor, finding
// yourself in the familiar halls of a North Pole research wing.
//
// Based on the large sign that says "teleporter hub", they seem to be
// researching teleportation; you can't help but try it for yourself and step
// onto the large yellow teleporter pad.
//
// Suddenly, you find yourself in an unfamiliar room! The room has no doors;
// the only way out is the teleporter. Unfortunately, the teleporter seems to
// be leaking magic smoke.
//
// Since this is a teleporter lab, there are lots of spare parts, manuals, and
// diagnostic equipment lying around. After connecting one of the diagnostic
// tools, it helpfully displays error code 0H-N0, which apparently means that
// there's an issue with one of the tachyon manifolds.
//
// You quickly locate a diagram of the tachyon manifold (your puzzle input). A
// tachyon beam enters the manifold at the location marked S; tachyon beams
// always move downward. Tachyon beams pass freely through empty space (.).
// However, if a tachyon beam encounters a splitter (^), the beam is stopped;
// instead, a new tachyon beam continues from the immediate left and from the
// immediate right of the splitter.
//
// For example:
//
// .......S.......
// ...............
// .......^.......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// In this example, the incoming tachyon beam (|) extends downward from S until
// it reaches the first splitter:
//
// .......S.......
// .......|.......
// .......^.......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// At that point, the original beam stops, and two new beams are emitted from
// the splitter:
//
// .......S.......
// .......|.......
// ......|^|......
// ...............
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// Those beams continue downward until they reach more splitters:
//
// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// ......^.^......
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// At this point, the two splitters create a total of only three tachyon beams,
// since they are both dumping tachyons into the same place between them:
//
// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// .....|^|^|.....
// ...............
// .....^.^.^.....
// ...............
// ....^.^...^....
// ...............
// ...^.^...^.^...
// ...............
// ..^...^.....^..
// ...............
// .^.^.^.^.^...^.
// ...............
//
// This process continues until all of the tachyon beams reach a splitter or exit the manifold:
//
// .......S.......
// .......|.......
// ......|^|......
// ......|.|......
// .....|^|^|.....
// .....|.|.|.....
// ....|^|^|^|....
// ....|.|.|.|....
// ...|^|^|||^|...
// ...|.|.|||.|...
// ..|^|^|||^|^|..
// ..|.|.|||.|.|..
// .|^|||^||.||^|.
// .|.|||.||.||.|.
// |^|^|^|^|^|||^|
// |.|.|.|.|.|||.|
//
// To repair the teleporter, you first need to understand the beam-splitting
// properties of the tachyon manifold. In this example, a tachyon beam is split
// a total of 21 times.
//
// Analyze your manifold diagram. How many times will the beam be split?
func Day7Part1(filename string) int {
	grid := NewDay7GridFromFile(filename)
	// grid.Show()

	stack := stack.New[Laser]()
	stack.Push(NewLaser(grid.StartX, grid.StartY+1))

	result := 0

loop:
	for stack.Len() > 0 {
		// grid.Show()

		l := stack.Pop()

		var s LaserState
		for s = LaserStateContinue; s == LaserStateContinue; s = l.Advance(grid) {
		}

		switch s {
		case LaserStateEnd:
			continue loop
		case LaserStateDuplicate:
			split := false
			if grid.Read(l.X+1, l.Y) == '.' {
				split = true
				stack.Push(NewLaser(l.X+1, l.Y))
			}
			if grid.Read(l.X-1, l.Y) == '.' {
				split = true
				stack.Push(NewLaser(l.X-1, l.Y))
			}
			if split {
				result++
			}
		case LaserStateContinue:
			log.Fatalf("ERROR: unpexpected LaserStateContinue")
		}
	}

	// grid.Show()

	return result
}

// --- Part Two ---
//
// With your analysis of the manifold complete, you begin fixing the
// teleporter. However, as you open the side of the teleporter to replace the
// broken manifold, you are surprised to discover that it isn't a classical
// tachyon manifold - it's a quantum tachyon manifold.
//
// With a quantum tachyon manifold, only a single tachyon particle is sent
// through the manifold. A tachyon particle takes both the left and right path
// of each splitter encountered.
//
// Since this is impossible, the manual recommends the many-worlds
// interpretation of quantum tachyon splitting: each time a particle reaches a
// splitter, it's actually time itself which splits. In one timeline, the
// particle went left, and in the other timeline, the particle went right.
//
// To fix the manifold, what you really need to know is the number of timelines
// active after a single particle completes all of its possible journeys
// through the manifold.
//
// In the above example, there are many timelines. For instance, there's the
// timeline where the particle always went left:
//
// .......S.......
// .......|.......
// ......|^.......
// ......|........
// .....|^.^......
// .....|.........
// ....|^.^.^.....
// ....|..........
// ...|^.^...^....
// ...|...........
// ..|^.^...^.^...
// ..|............
// .|^...^.....^..
// .|.............
// |^.^.^.^.^...^.
// |..............
//
// Or, there's the timeline where the particle alternated going left and right
// at each splitter:
//
// .......S.......
// .......|.......
// ......|^.......
// ......|........
// ......^|^......
// .......|.......
// .....^|^.^.....
// ......|........
// ....^.^|..^....
// .......|.......
// ...^.^.|.^.^...
// .......|.......
// ..^...^|....^..
// .......|.......
// .^.^.^|^.^...^.
// ......|........
//
// Or, there's the timeline where the particle ends up at the same point as the
// alternating timeline, but takes a totally different path to get there:
//
// .......S.......
// .......|.......
// ......|^.......
// ......|........
// .....|^.^......
// .....|.........
// ....|^.^.^.....
// ....|..........
// ....^|^...^....
// .....|.........
// ...^.^|..^.^...
// ......|........
// ..^..|^.....^..
// .....|.........
// .^.^.^|^.^...^.
// ......|........
//
// In this example, in total, the particle ends up on 40 different timelines.
//
// Apply the many-worlds interpretation of quantum tachyon splitting to your
// manifold diagram. In total, how many different timelines would a single
// tachyon particle end up on?
func Day7Part2(filename string) int {
	return 0
}

type Day7Grid struct {
	cells  [][]Day7Cell
	StartX int
	StartY int
	Height int
}

type Day7Cell struct {
	value byte
}

func NewDay7GridFromFile(filename string) Day7Grid {
	file, err := os.Open(filename)
	if err != nil {
		log.Fatalf("can't open file %q: %v", filename, err)
	}

	var grid Day7Grid

	r := bufio.NewReader(file)
	y := 0
	for line, _, err := r.ReadLine(); err != io.EOF; line, _, err = r.ReadLine() {
		if err != nil {
			log.Fatalf("can't read bank: %v", err)
		}

		row := make([]Day7Cell, len(line))
		for x, c := range line {
			if c == 'S' {
				grid.StartX = x
				grid.StartY = y
			}
			row[x].value = c
		}

		grid.cells = append(grid.cells, row)
		y++
	}

	grid.Height = y

	return grid
}

func (grid Day7Grid) Show() {
	fmt.Print(" ")
	for x := range len(grid.cells[0]) {
		fmt.Print(x % 10)
	}

	grid.Each(func(x, y int, value byte) {
		if x == 0 {
			fmt.Printf("\n%d", y%10)
		}
		fmt.Printf("%c", value)
	})
	fmt.Println()
	fmt.Println()
}

func (grid Day7Grid) Write(x, y int, value byte) byte {
	if y < 0 || y >= len(grid.cells) || x < 0 || x >= len(grid.cells[y]) {
		return 0
	}
	grid.cells[y][x].value = value
	return value
}

func (grid Day7Grid) Read(x, y int) byte {
	if y < 0 || y >= len(grid.cells) || x < 0 || x >= len(grid.cells[y]) {
		return 0
	}
	return grid.cells[y][x].value
}

func (grid Day7Grid) Each(fn func(x, y int, value byte)) {
	for y := range len(grid.cells) {
		for x := range len(grid.cells[y]) {
			fn(x, y, grid.cells[y][x].value)
		}
	}
}

type Laser struct {
	X, Y int
}

func NewLaser(x, y int) Laser {
	return Laser{X: x, Y: y}
}

type LaserState byte

const (
	LaserStateContinue  = LaserState(1)
	LaserStateDuplicate = LaserState(2)
	LaserStateEnd       = LaserState(3)
)

func (l *Laser) Advance(grid Day7Grid) LaserState {
	grid.Write(l.X, l.Y, '|')
	l.Y++
	if grid.Read(l.X, l.Y) == '^' {
		return LaserStateDuplicate
	}
	if grid.Read(l.X, l.Y) == '|' {
		return LaserStateEnd
	}
	if l.Y >= grid.Height {
		return LaserStateEnd
	}
	return LaserStateContinue
}
